// This file has been autogenerated.
// Do not modify manually.
//
#include <anton/optional.hpp>
#include <glang_syntax/syntax.hpp>

namespace glang {
  Syntax_Token const& get_variable_identifier(Syntax_Node const& node)
  {
    ANTON_ASSERT(node.kind == Syntax_Node_Kind::variable,
                 "node is not variable");
    ANTON_ASSERT(node.children.size() > (0), "variable has too few children");
    ANTON_ASSERT(node.children[0].is_right(),
                 "identifier in variable is not Syntax_Token");
    return node.children[0].right();
  }

  anton::Optional<Syntax_Token const&>
  get_variable_size(Syntax_Node const& node)
  {
    ANTON_ASSERT(node.kind == Syntax_Node_Kind::variable,
                 "node is not variable");
    if(node.children.size() > (2)) {
      ANTON_ASSERT(node.children[2].is_right(),
                   "size in variable is not Syntax_Token");
      return node.children[2].right();
    } else {
      return anton::null_optional;
    }
  }

  Syntax_Token const& get_decl_procedure_identifier(Syntax_Node const& node)
  {
    ANTON_ASSERT(node.kind == Syntax_Node_Kind::decl_procedure,
                 "node is not decl_procedure");
    ANTON_ASSERT(node.children.size() > (1),
                 "decl_procedure has too few children");
    ANTON_ASSERT(node.children[1].is_right(),
                 "identifier in decl_procedure is not Syntax_Token");
    return node.children[1].right();
  }

  Syntax_Node const& get_decl_procedure_parameter_list(Syntax_Node const& node)
  {
    ANTON_ASSERT(node.kind == Syntax_Node_Kind::decl_procedure,
                 "node is not decl_procedure");
    ANTON_ASSERT(node.children.size() > (2),
                 "decl_procedure has too few children");
    ANTON_ASSERT(node.children[2].is_left(),
                 "parameter_list in decl_procedure is not Syntax_Node");
    return node.children[2].left();
  }

  Syntax_Node const&
  get_decl_procedure_declaration_list(Syntax_Node const& node)
  {
    ANTON_ASSERT(node.kind == Syntax_Node_Kind::decl_procedure,
                 "node is not decl_procedure");
    ANTON_ASSERT(node.children.size() > (4),
                 "decl_procedure has too few children");
    ANTON_ASSERT(node.children[4].is_left(),
                 "declaration_list in decl_procedure is not Syntax_Node");
    return node.children[4].left();
  }

  Syntax_Node const& get_decl_procedure_body(Syntax_Node const& node)
  {
    ANTON_ASSERT(node.kind == Syntax_Node_Kind::decl_procedure,
                 "node is not decl_procedure");
    ANTON_ASSERT(node.children.size() > (6),
                 "decl_procedure has too few children");
    ANTON_ASSERT(node.children[6].is_left(),
                 "body in decl_procedure is not Syntax_Node");
    return node.children[6].left();
  }

  Syntax_Node const& get_decl_main_declaration_list(Syntax_Node const& node)
  {
    ANTON_ASSERT(node.kind == Syntax_Node_Kind::decl_main,
                 "node is not decl_main");
    ANTON_ASSERT(node.children.size() > (2), "decl_main has too few children");
    ANTON_ASSERT(node.children[2].is_left(),
                 "declaration_list in decl_main is not Syntax_Node");
    return node.children[2].left();
  }

  Syntax_Node const& get_decl_main_body(Syntax_Node const& node)
  {
    ANTON_ASSERT(node.kind == Syntax_Node_Kind::decl_main,
                 "node is not decl_main");
    ANTON_ASSERT(node.children.size() > (4), "decl_main has too few children");
    ANTON_ASSERT(node.children[4].is_left(),
                 "body in decl_main is not Syntax_Node");
    return node.children[4].left();
  }

  anton::Optional<Syntax_Token const&>
  get_procedure_parameter_T(Syntax_Node const& node)
  {
    ANTON_ASSERT(node.kind == Syntax_Node_Kind::procedure_parameter,
                 "node is not procedure_parameter");
    if(node.children.size() > (0)) {
      ANTON_ASSERT(node.children[0].is_right(),
                   "T in procedure_parameter is not Syntax_Token");
      return node.children[0].right();
    } else {
      return anton::null_optional;
    }
  }

  Syntax_Token const&
  get_procedure_parameter_identifier(Syntax_Node const& node)
  {
    ANTON_ASSERT(node.kind == Syntax_Node_Kind::procedure_parameter,
                 "node is not procedure_parameter");
    for(SNOT const& snot: node.children) {
      if(snot.is_right() && snot.right().kind == Syntax_Node_Kind::identifier) {
        return snot.right();
      }
    }
    ANTON_UNREACHABLE("identifier not present in procedure_parameter");
  };

  Syntax_Node const& get_expr_binary_lhs(Syntax_Node const& node)
  {
    ANTON_ASSERT(node.kind == Syntax_Node_Kind::expr_binary,
                 "node is not expr_binary");
    ANTON_ASSERT(node.children.size() > (0),
                 "expr_binary has too few children");
    ANTON_ASSERT(node.children[0].is_left(),
                 "lhs in expr_binary is not Syntax_Node");
    return node.children[0].left();
  }

  Syntax_Token const& get_expr_binary_operator(Syntax_Node const& node)
  {
    ANTON_ASSERT(node.kind == Syntax_Node_Kind::expr_binary,
                 "node is not expr_binary");
    ANTON_ASSERT(node.children.size() > (1),
                 "expr_binary has too few children");
    ANTON_ASSERT(node.children[1].is_right(),
                 "operator in expr_binary is not Syntax_Token");
    return node.children[1].right();
  }

  Syntax_Node const& get_expr_binary_rhs(Syntax_Node const& node)
  {
    ANTON_ASSERT(node.kind == Syntax_Node_Kind::expr_binary,
                 "node is not expr_binary");
    ANTON_ASSERT(node.children.size() > (2),
                 "expr_binary has too few children");
    ANTON_ASSERT(node.children[2].is_left(),
                 "rhs in expr_binary is not Syntax_Node");
    return node.children[2].left();
  }

  Syntax_Token const& get_expr_identifier_value(Syntax_Node const& node)
  {
    ANTON_ASSERT(node.kind == Syntax_Node_Kind::expr_identifier,
                 "node is not expr_identifier");
    ANTON_ASSERT(node.children.size() > (0),
                 "expr_identifier has too few children");
    ANTON_ASSERT(node.children[0].is_right(),
                 "value in expr_identifier is not Syntax_Token");
    return node.children[0].right();
  }

  Syntax_Token const& get_expr_index_base(Syntax_Node const& node)
  {
    ANTON_ASSERT(node.kind == Syntax_Node_Kind::expr_index,
                 "node is not expr_index");
    ANTON_ASSERT(node.children.size() > (0), "expr_index has too few children");
    ANTON_ASSERT(node.children[0].is_right(),
                 "base in expr_index is not Syntax_Token");
    return node.children[0].right();
  }

  Syntax_Node const& get_expr_index_index(Syntax_Node const& node)
  {
    ANTON_ASSERT(node.kind == Syntax_Node_Kind::expr_index,
                 "node is not expr_index");
    ANTON_ASSERT(node.children.size() > (2), "expr_index has too few children");
    ANTON_ASSERT(node.children[2].is_left(),
                 "index in expr_index is not Syntax_Node");
    return node.children[2].left();
  }

  Syntax_Token const& get_expr_lt_integer_value(Syntax_Node const& node)
  {
    ANTON_ASSERT(node.kind == Syntax_Node_Kind::expr_lt_integer,
                 "node is not expr_lt_integer");
    ANTON_ASSERT(node.children.size() > (0),
                 "expr_lt_integer has too few children");
    ANTON_ASSERT(node.children[0].is_right(),
                 "value in expr_lt_integer is not Syntax_Token");
    return node.children[0].right();
  }

  Syntax_Node const& get_stmt_if_condition(Syntax_Node const& node)
  {
    ANTON_ASSERT(node.kind == Syntax_Node_Kind::stmt_if, "node is not stmt_if");
    ANTON_ASSERT(node.children.size() > (1), "stmt_if has too few children");
    ANTON_ASSERT(node.children[1].is_left(),
                 "condition in stmt_if is not Syntax_Node");
    return node.children[1].left();
  }

  Syntax_Node const& get_stmt_if_then_branch(Syntax_Node const& node)
  {
    ANTON_ASSERT(node.kind == Syntax_Node_Kind::stmt_if, "node is not stmt_if");
    ANTON_ASSERT(node.children.size() > (3), "stmt_if has too few children");
    ANTON_ASSERT(node.children[3].is_left(),
                 "then_branch in stmt_if is not Syntax_Node");
    return node.children[3].left();
  }

  anton::Optional<Syntax_Node const&>
  get_stmt_if_else_branch(Syntax_Node const& node)
  {
    ANTON_ASSERT(node.kind == Syntax_Node_Kind::stmt_if, "node is not stmt_if");
    if(node.children.size() > (5)) {
      ANTON_ASSERT(node.children[5].is_left(),
                   "else_branch in stmt_if is not Syntax_Node");
      return node.children[5].left();
    } else {
      return anton::null_optional;
    }
  }

  Syntax_Token const& get_stmt_call_identifier(Syntax_Node const& node)
  {
    ANTON_ASSERT(node.kind == Syntax_Node_Kind::stmt_call,
                 "node is not stmt_call");
    ANTON_ASSERT(node.children.size() > (0), "stmt_call has too few children");
    ANTON_ASSERT(node.children[0].is_right(),
                 "identifier in stmt_call is not Syntax_Token");
    return node.children[0].right();
  }

  Syntax_Node const& get_stmt_call_arguments(Syntax_Node const& node)
  {
    ANTON_ASSERT(node.kind == Syntax_Node_Kind::stmt_call,
                 "node is not stmt_call");
    ANTON_ASSERT(node.children.size() > (2), "stmt_call has too few children");
    ANTON_ASSERT(node.children[2].is_left(),
                 "arguments in stmt_call is not Syntax_Node");
    return node.children[2].left();
  }

  Syntax_Node const& get_stmt_while_condition(Syntax_Node const& node)
  {
    ANTON_ASSERT(node.kind == Syntax_Node_Kind::stmt_while,
                 "node is not stmt_while");
    ANTON_ASSERT(node.children.size() > (1), "stmt_while has too few children");
    ANTON_ASSERT(node.children[1].is_left(),
                 "condition in stmt_while is not Syntax_Node");
    return node.children[1].left();
  }

  Syntax_Node const& get_stmt_while_statements(Syntax_Node const& node)
  {
    ANTON_ASSERT(node.kind == Syntax_Node_Kind::stmt_while,
                 "node is not stmt_while");
    ANTON_ASSERT(node.children.size() > (3), "stmt_while has too few children");
    ANTON_ASSERT(node.children[3].is_left(),
                 "statements in stmt_while is not Syntax_Node");
    return node.children[3].left();
  }

  Syntax_Node const& get_stmt_repeat_statements(Syntax_Node const& node)
  {
    ANTON_ASSERT(node.kind == Syntax_Node_Kind::stmt_repeat,
                 "node is not stmt_repeat");
    ANTON_ASSERT(node.children.size() > (1),
                 "stmt_repeat has too few children");
    ANTON_ASSERT(node.children[1].is_left(),
                 "statements in stmt_repeat is not Syntax_Node");
    return node.children[1].left();
  }

  Syntax_Node const& get_stmt_repeat_condition(Syntax_Node const& node)
  {
    ANTON_ASSERT(node.kind == Syntax_Node_Kind::stmt_repeat,
                 "node is not stmt_repeat");
    ANTON_ASSERT(node.children.size() > (3),
                 "stmt_repeat has too few children");
    ANTON_ASSERT(node.children[3].is_left(),
                 "condition in stmt_repeat is not Syntax_Node");
    return node.children[3].left();
  }

  Syntax_Node const& get_stmt_read_dst(Syntax_Node const& node)
  {
    ANTON_ASSERT(node.kind == Syntax_Node_Kind::stmt_read,
                 "node is not stmt_read");
    ANTON_ASSERT(node.children.size() > (1), "stmt_read has too few children");
    ANTON_ASSERT(node.children[1].is_left(),
                 "dst in stmt_read is not Syntax_Node");
    return node.children[1].left();
  }

  Syntax_Node const& get_stmt_write_src(Syntax_Node const& node)
  {
    ANTON_ASSERT(node.kind == Syntax_Node_Kind::stmt_write,
                 "node is not stmt_write");
    ANTON_ASSERT(node.children.size() > (1), "stmt_write has too few children");
    ANTON_ASSERT(node.children[1].is_left(),
                 "src in stmt_write is not Syntax_Node");
    return node.children[1].left();
  }

  Syntax_Node const& get_stmt_assign_dst(Syntax_Node const& node)
  {
    ANTON_ASSERT(node.kind == Syntax_Node_Kind::stmt_assign,
                 "node is not stmt_assign");
    ANTON_ASSERT(node.children.size() > (0),
                 "stmt_assign has too few children");
    ANTON_ASSERT(node.children[0].is_left(),
                 "dst in stmt_assign is not Syntax_Node");
    return node.children[0].left();
  }

  Syntax_Node const& get_stmt_assign_src(Syntax_Node const& node)
  {
    ANTON_ASSERT(node.kind == Syntax_Node_Kind::stmt_assign,
                 "node is not stmt_assign");
    ANTON_ASSERT(node.children.size() > (2),
                 "stmt_assign has too few children");
    ANTON_ASSERT(node.children[2].is_left(),
                 "src in stmt_assign is not Syntax_Node");
    return node.children[2].left();
  }
} // namespace glang
